# 多轮工具调用解决方案设计

## 问题总结

1. **核心问题**：`kosong.step()` 只执行单轮操作，不支持自动多轮工具调用
2. **当前限制**：AI Assistant 每次调用都是独立的，没有历史对话状态

## 解决方案架构

### 方案1：修改 AI Assistant 支持多轮调用（推荐）

**核心思路**：在 `ai_assistant.chat()` 中实现循环调用 `kosong.step()`

```python
async def chat(
    self,
    user_message: str,
    context: Optional[LinearContext] = None,
    history: Optional[List[Message]] = None,
) -> str:
    # 1. 准备消息历史
    if context:
        messages = context.history
    else:
        messages = history or []

    messages.append(Message(role="user", content=user_message))

    # 2. 多轮循环调用
    max_iterations = 5
    for iteration in range(max_iterations):
        # 调用 kosong.step
        result: StepResult = await kosong.step(...)

        # 将 AI 消息加入历史
        messages.append(result.message)

        # 获取工具调用结果
        tool_results = await result.tool_results()

        # 如果有工具调用，处理并继续下一轮
        if tool_results:
            for tool_result in tool_results:
                # 处理工具结果...
                tool_output = tool_result.result.output
                messages.append(Message(role="tool", content=tool_output))

            # 继续下一轮循环
            continue
        else:
            # 没有工具调用，结束
            break

    # 3. 更新 Context
    if context:
        for msg in messages[len(context.history):]:
            await context.add_message(msg)

    # 4. 返回最终回复
    return final_response
```

### 方案2：结合 Telegram ConversationHandler

**Telegram Context 作为状态管理**：

```python
# bot.py 中的 ConversationHandler
from telegram.ext import ConversationHandler

# 定义对话状态
(AWAITING_CONFIRMATION,
 PROJECT_ID,
 TASK_ID) = range(3)

async def start_ai_conversation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """启动AI对话"""
    context.user_data['ai_context'] = create_ai_context_for_user(update.effective_user.id)
    context.user_data['conversation_state'] = 'active'
    await update.message.reply_text("AI助手已启动，请输入您的问题...")

async def handle_ai_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """处理AI消息"""
    # 获取用户的AI上下文
    ai_context = context.user_data.get('ai_context')
    user_message = update.message.text

    # 调用AI助手（传入context）
    response = await ai_assistant.chat(user_message, context=ai_context)

    await update.message.reply_text(response)

    return ConversationHandler.END
```

## 实施步骤

### 步骤1：修改 AI Assistant

**文件**：`src/ai_assistant.py`

**修改内容**：
1. 添加 `LinearContext` 参数支持
2. 实现多轮循环调用逻辑
3. 持久化消息历史

### 步骤2：创建用户上下文管理器

**文件**：`src/utils/context_manager.py`

```python
from kosong.contrib.context.linear import LinearContext, JsonlLinearStorage
from pathlib import Path
from typing import Dict

class UserContextManager:
    """用户上下文管理器"""

    def __init__(self, storage_dir: Path):
        self.storage_dir = storage_dir
        self.user_contexts: Dict[int, LinearContext] = {}

    def get_context(self, user_id: int) -> LinearContext:
        """获取用户的AI上下文"""
        if user_id not in self.user_contexts:
            # 创建持久化存储
            storage_path = self.storage_dir / f"user_{user_id}.jsonl"
            storage = JsonlLinearStorage(storage_path)
            self.user_contexts[user_id] = LinearContext(storage)

        return self.user_contexts[user_id]
```

### 步骤3：修改 Bot 注册 ConversationHandler

**文件**：`src/bot.py`

```python
from telegram.ext import ConversationHandler

# 在 _register_handlers 中添加
conversation_handler = ConversationHandler(
    entry_points=[MessageHandler(filters.TEXT & ~filters.COMMAND, start_ai_conversation)],
    states={
        'active': [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_ai_message)],
    },
    fallbacks=[],
    per_user=True,  # 每个用户独立的上下文
)

self.application.add_handler(conversation_handler)
```

## Kosong Context 机制详解

**LinearContext 的优势**：
1. **持久化**：可持久化到 JSONL 文件
2. **记忆管理**：自动管理消息历史和 token 计数
3. **状态隔离**：每个用户独立的上下文

**数据流**：
```
用户消息 -> Kosong Context -> kosong.step -> 工具调用 -> 工具结果 -> 消息历史
                    ↓
        持久化到 user_{user_id}.jsonl
```

## 完整的数据流

```
1. 用户发送消息给 Bot
2. ConversationHandler 捕获消息
3. 从用户上下文管理器获取 LinearContext
4. AI Assistant 调用时传入 Context
5. AI Assistant 实现多轮循环：
   - 调用 kosong.step()
   - 处理工具调用结果
   - 将结果加入 Context
   - 继续下一轮循环
6. 更新 Context 持久化到文件
7. 返回最终回复给用户
```

## 好处

1. **多轮调用**：AI 可以连续调用多个工具
2. **历史记忆**：跨消息保持对话状态
3. **持久化**：用户重启对话后仍能保持历史
4. **用户隔离**：每个用户独立的上下文
5. **Token 管理**：自动管理 token 消耗

## 实施优先级

1. **高优先级**：修改 AI Assistant 实现多轮调用
2. **中优先级**：创建 UserContextManager
3. **低优先级**：集成 ConversationHandler（可选）

## 注意事项

1. **Token 限制**：需要限制历史消息数量，避免超出 LLM 限制
2. **存储清理**：定期清理旧的用户上下文文件
3. **错误处理**：处理上下文加载失败的情况
